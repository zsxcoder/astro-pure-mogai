---
import type { MarkdownHeading } from 'astro'

import config from '@/site-config'

import { generateToc } from '../../plugins/toc'
import TOCHeading from './TOCHeading.astro'

interface Props {
  headings: MarkdownHeading[]
  class?: string
  id?: string
}

const { headings, class: className, ...props } = Astro.props

const toc = generateToc(headings)

const { tocCollapse: collapse } = config.content || {}
---

<toc-heading class={className} data-collapse={String(collapse)} {...props}>
  <h2 class='font-semibold'>TABLE OF CONTENTS</h2>
  <ul class='mt-4 text-card-foreground'>
    {toc.map((heading) => <TOCHeading heading={heading} />)}
  </ul>
</toc-heading>

<script>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  interface TOCLink {
    element: HTMLAnchorElement
    progressBar: HTMLElement
    slug: string
  }

  interface HeadingProgress {
    inView: boolean
    progress: number
  }

  class TOC extends HTMLElement {
    headings: HTMLElement[] = []
    tocLinks: TOCLink[] = []
    headingProgress: Record<string, HeadingProgress> = {}
    collapse = false

    constructor() {
      super()
      this.collapse = this.dataset.collapse === 'true'

      // Initialize the headings and tocLinks
      this.headings = Array.from(
        document.querySelectorAll(
          'article h1, article h2, article h3, article h4, article h5, article h6'
        )
      )
      this.tocLinks = Array.from(this.querySelectorAll('a[href^="#"]')).map((link) => ({
        element: link as HTMLAnchorElement,
        progressBar: link.previousElementSibling as HTMLElement,
        slug: (link.getAttribute('href') || '').substring(1)
      }))
    }

    updatePositionAndStyle = () => {
      const windowHeight = window.innerHeight
      const pageOffset =
        window.scrollY - ((document.querySelector('#content') as HTMLElement)?.offsetTop || 0)
      const postOffset =
        ((document.querySelector('#content') as HTMLElement)?.offsetHeight || 0) + 127

      this.headings.forEach((el, index) => {
        const nextHeadingTop = this.headings[index + 1]?.offsetTop || postOffset
        const range = [el.offsetTop - pageOffset, nextHeadingTop - pageOffset - el.offsetHeight]
        const progress = (windowHeight - range[0]) / (range[1] - range[0])

        this.headingProgress[el.id] = {
          inView: range[0] < windowHeight && range[1] > 0,
          progress: Math.max(0, Math.min(1, progress))
        }
      })

      this.tocLinks.forEach(({ element: el, progressBar: bar, slug }, i) => {
        const { inView, progress } = this.headingProgress[slug] || { inView: false, progress: 0 }
        if (this.headingProgress[slug]) {
          el.classList.toggle('highlight', inView)
          el.classList.toggle('highlight-bg-translucent', inView)
          el.classList.toggle(
            'rounded-t-2xl',
            inView && (i == 0 || !this.headingProgress[this.tocLinks[i - 1]?.slug]?.inView)
          )
          el.classList.toggle(
            'rounded-b-2xl',
            inView &&
              (i == this.tocLinks.length - 1 ||
                !this.headingProgress[this.tocLinks[i + 1]?.slug]?.inView)
          )
          bar.classList.toggle('is-read', !inView && progress == 1)
          bar.classList.toggle('highlight-bg', inView)
          bar.style.setProperty('height', `${progress * 90}%`)
        }
      })

      if (this.collapse) {
        this.updateCollapseState()
      }
    }

    updateCollapseState = () => {
      const activeLinks = this.tocLinks.filter((link) =>
        link.element.classList.contains('highlight')
      )
      const ulsToShow = new Set<HTMLElement>()

      activeLinks.forEach((link) => {
        const li = link.element.closest('li')
        if (li) {
          // Show children
          const siblingUl = li.querySelector('ul')
          if (siblingUl) ulsToShow.add(siblingUl as HTMLElement)

          // Show parents
          let parent = li.parentElement
          while (parent && parent.tagName === 'UL') {
            ulsToShow.add(parent as HTMLElement)
            const nextParent = parent.parentElement?.closest('ul')
            parent = nextParent instanceof HTMLElement ? nextParent : null
          }
        }
      })

      const allUls = this.querySelectorAll('ul.toc-submenu')
      allUls.forEach((ul) => {
        if (ulsToShow.has(ul as HTMLElement)) {
          ul.classList.remove('hidden')
          ul.classList.add('expanded')
        } else {
          ul.classList.remove('expanded')
          // Delay adding hidden to allow transition, or just rely on CSS
          // ul.classList.add('hidden')
        }
      })
    }

    connectedCallback() {
      // Remove hidden class from all submenus to allow CSS transition
      if (this.collapse) {
        const allUls = this.querySelectorAll('ul.toc-submenu')
        allUls.forEach((ul) => {
          ul.classList.remove('hidden')
        })
      }

      // Smooth scroll
      this.tocLinks.forEach((link) => {
        link.element.addEventListener('click', (e) => {
          e.preventDefault()
          // Push the history to add the hash at the end of the URL
          const directHeading = this.headings.find((heading) => heading.id === link.slug)
          if (directHeading) {
            // Push the history to add the hash at the end of the URL
            history.pushState(
              null,
              directHeading.textContent || '',
              link.element.getAttribute('href')
            )
            directHeading.scrollIntoView({ behavior: 'smooth' })
          } else {
            console.warn(`No heading found for slug: ${link.slug}`)
          }
        })
      })

      // Initial first and listen to scroll event
      setInterval(this.updatePositionAndStyle, 100)
      window.addEventListener('scroll', this.updatePositionAndStyle)
    }
  }

  customElements.define('toc-heading', TOC)
</script>

<style>
  toc-heading :global(.toc-item) {
    display: flow-root;
  }
  /* Ensure hidden class works if not provided by utility classes */
  toc-heading :global(.hidden) {
    display: none;
  }

  /* CSS Transition for TOC collapse */
  toc-heading[data-collapse='true'] :global(.toc-submenu) {
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    transition:
      max-height 0.3s ease-in-out,
      opacity 0.3s ease-in-out;
  }

  toc-heading[data-collapse='true'] :global(.toc-submenu.expanded) {
    max-height: 100vh; /* Adjust this value if TOC is very long */
    opacity: 1;
  }
</style>
