---
import type { MarkdownHeading } from 'astro'

import { generateToc } from '../../plugins/toc'
import TOCHeading from './TOCHeading.astro'

interface Props {
  headings: MarkdownHeading[]
  class?: string
  id?: string
}

const { headings, class: className, ...props } = Astro.props

const toc = generateToc(headings)
---

<toc-heading class={className} {...props}>
  <h2 class='font-medium'>TABLE OF CONTENTS</h2>
  <ul class='mt-4'>
    {toc.map((heading) => <TOCHeading heading={heading} />)}
  </ul>
</toc-heading>

<script>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  interface TOCLink {
    element: HTMLAnchorElement
    progressBar: HTMLElement
    slug: string
  }

  interface HeadingProgress {
    inView: boolean
    progress: number
  }

  class TOC extends HTMLElement {
    headings: HTMLElement[] = []
    tocLinks: TOCLink[] = []
    headingProgress: Record<string, HeadingProgress> = {}

    constructor() {
      super()
      // Initialize tocLinks immediately, but headings will be updated dynamically
      this.tocLinks = Array.from(this.querySelectorAll('a[href^="#"]')).map((link) => ({
        element: link as HTMLAnchorElement,
        progressBar: link.previousElementSibling as HTMLElement,
        slug: (link.getAttribute('href') || '').substring(1)
      }))
    }

    // Update headings dynamically to include client-side rendered components
    updateHeadings() {
      this.headings = Array.from(
        document.querySelectorAll(
          'article h1, article h2, article h3, article h4, article h5, article h6'
        )
      )
    }

    updatePositionAndStyle = () => {
      // Update headings dynamically to handle client-side rendered components
      this.updateHeadings()
      
      const windowHeight = window.innerHeight
      const contentElement = document.querySelector('#content') as HTMLElement
      if (!contentElement) return
      
      // Get content element position relative to viewport
      const contentRect = contentElement.getBoundingClientRect()
      const contentTop = contentRect.top + window.scrollY
      const contentHeight = contentElement.offsetHeight
      
      // Reset headingProgress for all slugs
      this.tocLinks.forEach(({ slug }) => {
        this.headingProgress[slug] = {
          inView: false,
          progress: 0
        }
      })

      // Update progress for all headings
      this.headings.forEach((el, index) => {
        if (!el.id) return
        
        // Get heading position relative to viewport and document
        const headingRect = el.getBoundingClientRect()
        const headingTop = headingRect.top + window.scrollY
        const headingBottom = headingRect.bottom + window.scrollY
        
        // Calculate next heading top or content bottom
        const nextHeading = this.headings[index + 1]
        const nextHeadingTop = nextHeading ? (nextHeading.getBoundingClientRect().top + window.scrollY) : (contentTop + contentHeight)
        
        // Calculate heading range relative to content
        const headingRangeStart = headingTop - contentTop
        const headingRangeEnd = nextHeadingTop - contentTop
        const headingRangeHeight = headingRangeEnd - headingRangeStart
        
        // Calculate scroll position relative to content
        const scrollPosition = window.scrollY - contentTop
        const viewportBottomInContent = scrollPosition + windowHeight
        
        // Determine if heading is in view
        const inView = headingTop < viewportBottomInContent && headingBottom > scrollPosition
        
        // Calculate progress
        const progress = Math.max(0, Math.min(1, (viewportBottomInContent - headingRangeStart) / headingRangeHeight))

        this.headingProgress[el.id] = {
          inView,
          progress
        }
      })

      // Update TOC links based on heading progress
      this.tocLinks.forEach(({ element: el, progressBar: bar, slug }, i) => {
        const progressData = this.headingProgress[slug] || { inView: false, progress: 0 }
        const { inView, progress } = progressData
        
        el.classList.toggle('highlight', inView)
        el.classList.toggle('highlight-bg-translucent', inView)
        el.classList.toggle(
          'rounded-t-2xl',
          inView && (i === 0 || !(this.headingProgress[this.tocLinks[i - 1]?.slug]?.inView))
        )
        el.classList.toggle(
          'rounded-b-2xl',
          inView &&
            (i === this.tocLinks.length - 1 ||
              !(this.headingProgress[this.tocLinks[i + 1]?.slug]?.inView))
        )
        bar.classList.toggle('is-read', !inView && progress === 1)
        bar.classList.toggle('highlight-bg', inView)
        bar.style.setProperty('height', `${progress * 90}%`)
      })
    }

    connectedCallback() {
      // Smooth scroll
      this.tocLinks.forEach((link) => {
        link.element.addEventListener('click', (e) => {
          e.preventDefault()
          // Push the history to add the hash at the end of the URL
          const directHeading = this.headings.find((heading) => heading.id === link.slug)
          if (directHeading) {
            // Push the history to add the hash at the end of the URL
            history.pushState(
              null,
              directHeading.textContent || '',
              link.element.getAttribute('href')
            )
            directHeading.scrollIntoView({ behavior: 'smooth' })
          } else {
            console.warn(`No heading found for slug: ${link.slug}`)
          }
        })
      })

      // Initial update and listen to scroll event
      this.updateHeadings()
      this.updatePositionAndStyle()
      setInterval(this.updatePositionAndStyle, 100)
      window.addEventListener('scroll', this.updatePositionAndStyle)
      
      // Listen for dynamic content changes
      const observer = new MutationObserver(() => {
        this.updateHeadings()
        this.updatePositionAndStyle()
      })
      const articleElement = document.querySelector('article')
      if (articleElement) {
        observer.observe(articleElement, {
          childList: true,
          subtree: true
        })
      }
    }
  }

  customElements.define('toc-heading', TOC)
</script>

<style>
  toc-heading :global(.toc-item) {
    display: flow-root;
  }
</style>
