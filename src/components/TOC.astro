---
import type { MarkdownHeading } from 'astro'

import { generateToc } from '../../packages/pure/plugins/toc'
import TOCHeading from '../../packages/pure/components/pages/TOCHeading.astro'

interface Props {
  headings: MarkdownHeading[]
  class?: string
  id?: string
}

const { headings, class: className, ...props } = Astro.props

const toc = generateToc(headings)
---

<toc-heading class={className} {...props}>
  <h2 class='font-medium'>目录</h2>
  <ul class='mt-4'>
    {toc.map((heading) => <TOCHeading heading={heading} />)}
  </ul>
</toc-heading>

<script>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  interface TOCLink {
    element: HTMLAnchorElement
    progressBar: HTMLElement
    slug: string
  }

  interface HeadingProgress {
    inView: boolean
    progress: number
  }

  class TOC extends HTMLElement {
    headings: HTMLElement[] = []
    tocLinks: TOCLink[] = []
    headingProgress: Record<string, HeadingProgress> = {}

    constructor() {
      super()
      // Initialize headings and tocLinks later to ensure dynamic components are loaded
    }

    // Method to update headings array dynamically
    updateHeadings() {
      this.headings = Array.from(
        document.querySelectorAll(
          'article h1, article h2, article h3, article h4, article h5, article h6'
        )
      )
    }

    // Method to update tocLinks array dynamically
    updateTOCLinks() {
      const newTocLinks = Array.from(this.querySelectorAll('a[href^="#"]')).map((link) => ({
        element: link as HTMLAnchorElement,
        progressBar: link.previousElementSibling as HTMLElement,
        slug: (link.getAttribute('href') || '').substring(1)
      }))

      // Add click event listeners to new links only
      newTocLinks.forEach((newLink) => {
        const isExisting = this.tocLinks.some((existingLink) => existingLink.element === newLink.element)
        if (!isExisting) {
          // Remove any existing event listeners to avoid duplicates
          newLink.element.removeEventListener('click', this.handleTOCLinkClick)
          // Add new event listener
          newLink.element.addEventListener('click', this.handleTOCLinkClick.bind(this))
        }
      })

      this.tocLinks = newTocLinks
    }

    // Handle TOC link click
    handleTOCLinkClick(e: Event) {
      e.preventDefault()
      const link = e.target as HTMLAnchorElement
      const slug = (link.getAttribute('href') || '').substring(1)
      const directHeading = document.getElementById(slug)
      if (directHeading) {
        // Push the history to add the hash at the end of the URL
        history.pushState(
          null,
          directHeading.textContent || '',
          link.getAttribute('href')
        )
        directHeading.scrollIntoView({ behavior: 'smooth' })
      } else {
        console.warn(`No heading found for slug: ${slug}`)
      }
    }

    updatePositionAndStyle = () => {
      // Update headings and tocLinks arrays to include dynamically loaded components
      this.updateHeadings()
      this.updateTOCLinks()
      
      const windowHeight = window.innerHeight
      const contentEl = document.querySelector('#content') as HTMLElement
      const contentRect = contentEl?.getBoundingClientRect() || { top: 0, height: 0 }
      const contentTop = contentRect.top + window.scrollY
      const postOffset = contentTop + (contentEl?.offsetHeight || 0) + 127

      this.headings.forEach((el, index) => {
        const elRect = el.getBoundingClientRect()
        const elTop = elRect.top + window.scrollY
        const nextHeading = this.headings[index + 1]
        const nextHeadingTop = nextHeading ? nextHeading.getBoundingClientRect().top + window.scrollY : postOffset
        
        // Calculate range relative to viewport
        const elViewportTop = elRect.top
        const nextHeadingViewportTop = nextHeading ? nextHeading.getBoundingClientRect().top : windowHeight
        const range = [elViewportTop, nextHeadingViewportTop]
        const progress = (windowHeight - range[0]) / (range[1] - range[0])

        this.headingProgress[el.id] = {
          inView: range[0] < windowHeight && range[1] > 0,
          progress: Math.max(0, Math.min(1, progress))
        }
      })

      this.tocLinks.forEach(({ element: el, progressBar: bar, slug }, i) => {
        const { inView, progress } = this.headingProgress[slug] || { inView: false, progress: 0 }
        el.classList.toggle('highlight', inView)
        el.classList.toggle('highlight-bg-translucent', inView)
        el.classList.toggle(
          'rounded-t-2xl',
          inView && (i === 0 || !this.headingProgress[this.tocLinks[i - 1]?.slug]?.inView)
        )
        el.classList.toggle(
          'rounded-b-2xl',
          inView &&
            (i === this.tocLinks.length - 1 ||
              !this.headingProgress[this.tocLinks[i + 1]?.slug]?.inView)
        )
        bar.classList.toggle('is-read', !inView)
        bar.classList.toggle('highlight-bg', inView)
        // Set height to 90% when in view, 0% otherwise
        bar.style.setProperty('height', inView ? '90%' : '0%')
      })
    }

    connectedCallback() {
      // Initialize headings and tocLinks
      this.updateHeadings()
      this.updateTOCLinks()

      // Smooth scroll - we'll add click listeners dynamically in updatePositionAndStyle

      // Initial first and listen to scroll event
      setInterval(this.updatePositionAndStyle, 100)
      window.addEventListener('scroll', this.updatePositionAndStyle)
    }
  }

  customElements.define('toc-heading', TOC)
</script>

<style>
  toc-heading :global(.toc-item) {
    display: flow-root;
  }
</style>
