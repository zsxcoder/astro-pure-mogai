---
import { Icon } from 'astro-pure/user'

const limit = 5
const refreshMs = 60_000
---

<div class='recent-comments' data-recent-comments data-limit={limit} data-refresh-ms={refreshMs}>
  <div class='recent-comments-title'>
    <Icon name='list' class='me-2' color='#A6923F' />
    <span>最新评论</span>
  </div>

  <div class='comment-list'>
    <div class='comment-empty'>加载中...</div>
  </div>
</div>

<script
  is:inline
  type='module'
  data-astro-rerun
  define:vars={{
    defaultLimit: limit,
    defaultRefreshMs: refreshMs
  }}
>
  const formatCommentTime = (timestamp) => {
    const date = new Date(timestamp)
    const diff = Date.now() - date.getTime()

    if (diff < 60 * 1000) return '刚刚'
    if (diff < 60 * 60 * 1000) return `${Math.floor(diff / (60 * 1000))}分钟前`
    if (diff < 24 * 60 * 60 * 1000) return `${Math.floor(diff / (60 * 60 * 1000))}小时前`
    if (diff < 7 * 24 * 60 * 60 * 1000) return `${Math.floor(diff / (24 * 60 * 60 * 1000))}天前`

    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`
  }

  const stripHtml = (html) => {
    const doc = new DOMParser().parseFromString(String(html || ''), 'text/html')
    return doc.body.textContent || ''
  }

  const truncateText = (text, length = 100) => {
    const s = String(text || '')
    if (s.length <= length) return s
    return s.slice(0, length) + '...'
  }

  const normalizeUrl = (url) => {
    const s = String(url || '')
    if (!s) return '#'
    return s.endsWith('/') ? s.slice(0, -1) : s
  }

  const buildKey = (items) =>
    items.map((c) => `${c.nick ?? ''}|${c.time ?? ''}|${c.url ?? ''}|${c.avatar ?? ''}`).join('||')

  const renderComments = (root, comments) => {
    const listEl = root.querySelector('.comment-list')
    if (!listEl) return

    listEl.replaceChildren()

    if (!comments.length) {
      const empty = document.createElement('div')
      empty.className = 'comment-empty'
      empty.textContent = '暂无评论数据'
      listEl.appendChild(empty)
      return
    }

    const frag = document.createDocumentFragment()

    for (const comment of comments) {
      const item = document.createElement('div')
      item.className = 'comment-item'

      const avatarWrap = document.createElement('div')
      avatarWrap.className = 'comment-avatar'

      const img = document.createElement('img')
      img.src = comment.avatar || ''
      img.alt = comment.nick || ''
      img.loading = 'lazy'
      avatarWrap.appendChild(img)

      const content = document.createElement('div')
      content.className = 'comment-content'

      const meta = document.createElement('div')
      meta.className = 'comment-meta'

      const author = document.createElement('span')
      author.className = 'comment-author'
      author.textContent = comment.nick || ''

      const time = document.createElement('span')
      time.className = 'comment-time'
      time.dataset.time = String(comment.time || '')
      time.textContent = comment.time ? formatCommentTime(comment.time) : ''

      meta.append(author, time)

      const text = document.createElement('a')
      text.className = 'comment-text'
      text.textContent = truncateText(stripHtml(comment.comment), 100)
      text.href = normalizeUrl(comment.url)

      content.append(meta, text)
      item.append(avatarWrap, content)

      frag.appendChild(item)
    }

    listEl.appendChild(frag)
  }

  const updateTimesOnly = (root) => {
    const timeEls = root.querySelectorAll('.comment-time[data-time]')
    timeEls.forEach((el) => {
      const timestamp = Number(el.dataset.time)
      if (!Number.isFinite(timestamp) || timestamp <= 0) return
      el.textContent = formatCommentTime(timestamp)
    })
  }

  const fetchRecentComments = async (limit, signal) => {
    try {
      // 使用新的 worker 端点
      const apiUrl = 'https://giscus.mcyzsx.top/api/giscus'
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          owner: 'zsxcoder',
          repo: 'astro-pure-mogai'
        }),
        signal
      })
      
      if (!response.ok) {
        throw new Error(`获取评论失败: ${response.status}`)
      }

      const result = await response.json()
      
      // 检查响应结构
      if (!result || !result.data || !result.data.repository || !result.data.repository.discussions || !result.data.repository.discussions.nodes) {
        console.warn('响应数据结构不完整，返回空评论列表')
        return []
      }
      
      // 获取所有讨论
      const discussions = result.data.repository.discussions.nodes
      
      // 收集所有评论
      let allComments = []
      
      discussions.forEach(discussion => {
        // 跳过没有评论的讨论
        if (!discussion.comments || !discussion.comments.nodes || !discussion.comments.nodes.length) return
        
        // 从讨论标题中提取页面 URL
        let url = '/'
        try {
          const title = discussion.title.trim()
          if (title) {
            url = title.startsWith('/') ? title : `/${title}`
          }
        } catch (error) {
          console.error('解析评论 URL 出错:', error)
        }
        
        // 处理每条评论
        discussion.comments.nodes.forEach(comment => {
          // 处理匿名用户
          const authorName = comment.author?.login || '匿名用户'
          const avatarUrl = comment.author?.avatarUrl || 'https://github.com/ghost.png'
          
          allComments.push({
            nick: authorName,
            comment: comment.body || '',
            url: url,
            avatar: avatarUrl,
            time: comment.createdAt ? new Date(comment.createdAt).getTime() : Date.now(),
            like: 0 // 暂不支持点赞数
          })
        })
      })
      
      // 按时间排序（最新的在前）
      allComments.sort((a, b) => b.time - a.time)
      
      // 返回指定数量的评论
      return allComments.slice(0, limit)
    } catch (error) {
      console.error('获取最新评论出错:', error)
      return []
    }
  }

  const initRecentComments = (root) => {
    const limit = Number(root.dataset.limit || defaultLimit) || defaultLimit
    const refreshMs = Number(root.dataset.refreshMs || defaultRefreshMs) || defaultRefreshMs

    let lastKey = ''
    const aborter = new AbortController()

    const tick = async () => {
      try {
        const list = await fetchRecentComments(limit, aborter.signal)
        const items = list.slice(0, limit)
        const key = items.length ? buildKey(items) : '__EMPTY__'

        if (key !== lastKey) {
          lastKey = key
          renderComments(root, items)
        } else {
          updateTimesOnly(root)
        }
      } catch (e) {
        if (e?.name === 'AbortError') return
        console.error('Recent comments error:', e)
        const listEl = root.querySelector('.comment-list')
        if (listEl) {
          listEl.innerHTML = `<div class="comment-empty error">加载失败: ${e.message}</div>`
        }
      }
    }

    tick()

    const timer = window.setInterval(() => {
      if (document.hidden) return
      tick()
    }, refreshMs)

    const onVisible = () => {
      if (!document.hidden) tick()
    }
    document.addEventListener('visibilitychange', onVisible)

    return () => {
      aborter.abort()
      window.clearInterval(timer)
      document.removeEventListener('visibilitychange', onVisible)
    }
  }

  const disposers = new Set()

  const boot = () => {
    document.querySelectorAll('[data-recent-comments]').forEach((root) => {
      if (root.__recentCommentsInited) return
      root.__recentCommentsInited = true
      disposers.add(initRecentComments(root))
    })
  }

  const disposeAll = () => {
    disposers.forEach((fn) => fn())
    disposers.clear()
  }

  // 渲染函数
  function renderGiscusComments(discussions) {
    // 找到所有评论容器
    const containers = document.querySelectorAll('[data-recent-comments] .comment-list');
    
    containers.forEach(container => {
      // 清空容器
      container.innerHTML = '';
      
      let hasComments = false;
      
      discussions.forEach(discussion => {
        // 跳过空评论
        if (!discussion.comments || !discussion.comments.nodes || !discussion.comments.nodes.length) return;
        
        discussion.comments.nodes.forEach(comment => {
          hasComments = true;
          
          const div = document.createElement('div');
          div.className = 'comment-item';
          
          // 从讨论标题中提取页面 URL
          let url = '/'
          try {
            const title = discussion.title.trim()
            if (title) {
              url = title.startsWith('/') ? title : `/${title}`
            }
          } catch (error) {
            console.error('解析评论 URL 出错:', error)
          }
          
          // 处理匿名用户
          const authorName = comment.author?.login || '匿名用户';
          const avatarUrl = comment.author?.avatarUrl || 'https://github.com/ghost.png';
          
          // 创建评论元素
          const avatarWrap = document.createElement('div');
          avatarWrap.className = 'comment-avatar';
          
          const img = document.createElement('img');
          img.src = avatarUrl;
          img.alt = authorName;
          img.loading = 'lazy';
          avatarWrap.appendChild(img);
          
          const content = document.createElement('div');
          content.className = 'comment-content';
          
          const meta = document.createElement('div');
          meta.className = 'comment-meta';
          
          const author = document.createElement('span');
          author.className = 'comment-author';
          author.textContent = authorName;
          
          const time = document.createElement('span');
          time.className = 'comment-time';
          time.dataset.time = String(comment.createdAt ? new Date(comment.createdAt).getTime() : Date.now());
          time.textContent = comment.createdAt ? formatCommentTime(new Date(comment.createdAt).getTime()) : '';
          
          meta.append(author, time);
          
          const text = document.createElement('a');
          text.className = 'comment-text';
          text.textContent = stripHtml(comment.body || '');
          text.href = normalizeUrl(url);
          
          content.append(meta, text);
          div.append(avatarWrap, content);
          
          container.appendChild(div);
        });
      });
      
      // 如果没有评论，显示空状态
      if (!hasComments) {
        const empty = document.createElement('div');
        empty.className = 'comment-empty';
        empty.textContent = '暂无评论数据';
        container.appendChild(empty);
      }
    });
  }

  // 调用 API
  async function loadComments() {
    try {
      const response = await fetch('https://giscus.mcyzsx.top/api/giscus', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ owner: 'zsxcoder', repo: 'astro-pure-mogai' })
      });
      
      const result = await response.json();
      
      // 检查响应结构
      if (!result || !result.data || !result.data.repository || !result.data.repository.discussions || !result.data.repository.discussions.nodes) {
        console.warn('响应数据结构不完整，无法加载评论');
        console.log(result);
        return;
      }
      
      const discussions = result.data.repository.discussions.nodes;
      
      renderGiscusComments(discussions);
    } catch (error) {
      console.error('加载失败:', error);
      
      // 显示错误信息
      const containers = document.querySelectorAll('[data-recent-comments] .comment-list');
      containers.forEach(container => {
        container.innerHTML = '<div class="comment-empty error">加载评论失败</div>';
      });
    }
  }

  const start = () => boot()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', start, { once: true })
  } else {
    start()
  }

  document.addEventListener('astro:page-load', boot)
  document.addEventListener('astro:before-swap', disposeAll)
  
  // 暴露 loadComments 函数到全局，便于调试
  window.loadComments = loadComments;
</script>

<style is:global>
  @import '@/assets/styles/rc.css';
</style>